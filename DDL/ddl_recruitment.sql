-- _______________SET AUTOCOMMIT MODE ON___________________________

-- drop database
DROP DATABASE IF EXISTS recruitment;
-- database creation
CREATE DATABASE recruitment;

-- _______________CONNECT TO THE DATABASE__________________________
-- _______________TRANSACTION MODE MANUAL\AUTOCOMMIT_______________ 

-- drop default schema
DROP SCHEMA IF EXISTS public;

DROP SCHEMA IF EXISTS recruitment CASCADE;
-- create new schema
CREATE SCHEMA recruitment;

-- _______________SELECT RECRUITMENT SCHEMA FOR OBJECTS____________

-- extensions creation (for functions and indexes)
CREATE EXTENSION IF NOT EXISTS plpgsql WITH SCHEMA pg_catalog;
CREATE EXTENSION IF NOT EXISTS btree_gist;

-- set the search path (if there are any other schemas)
SET search_path = recruitment, pg_catalog;

-- _______________DOMAINS AND TYPES________________________________

-- email domain creation (regular expression matches an email pattern)
CREATE DOMAIN email_pattern AS VARCHAR(255)
CONSTRAINT email_pattern_check CHECK (VALUE ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$');

-- domain that checks if the value is not an empty or blank string (will be applied for names and phones fields)
CREATE DOMAIN nonempty_string AS VARCHAR(100) 
CONSTRAINT nonempty_string_check CHECK (CHAR_LENGTH(TRIM(BOTH FROM VALUE)) > 0);

-- create types for contracts
CREATE TYPE contract_type AS ENUM (
    'FIXED-TERM',
    'PERMANENT',
    'TEMPORARY',
    'ZERO-HOURS',
    'SELF-EMPLOYMENT',
    'INTERNSHIP',
    'APPRENTICESHIP'
);
							
							
-- create types for skill levels
CREATE TYPE lvl_type AS ENUM (
    'BEGINNER',
    'INTERMEDIATE',
    'ADVANCED',
    'PROFESSIONAL',
    'EXPERT'
);		

-- I specified NOT NULL constraint not in TYPES but in columns becaus in some cases a NULL can be considered of the domain type
								  
--_______________FUNCTIONS_______________

-- create birth check function (birth date schould be between 1930-01-01 and current date)
CREATE OR REPLACE FUNCTION check_birth_date() RETURNS TRIGGER
    LANGUAGE plpgsql
    AS $$
BEGIN
  IF( NEW.birth_date < DATE '1930-01-01' OR 
      NEW.birth_date > NOW() )
  THEN
    RAISE EXCEPTION
      'Birth date must be later than Jan 1, 1930 and earlier than today' 
    				;
  END IF;
  RETURN NEW;
END;
$$;

-- create update_ts check function
CREATE OR REPLACE FUNCTION check_date() RETURNS TRIGGER
    LANGUAGE plpgsql
    AS $$
BEGIN
	-- let's assume that our db will contain information since 2023
  IF( NEW.update_ts < DATE '2023-01-01' OR 
      NEW.update_ts > NOW() )
  
  THEN
    RAISE EXCEPTION
      'Date must be later than Jan 1, 2023 and earlier than today';
  END IF;
  RETURN NEW;
END;
$$;

-- function that automatically sets the value of a 'update_date' column to the current timestamp whenever a row in a specific table is updated
CREATE OR REPLACE FUNCTION update_date_trigger() RETURNS TRIGGER
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.update_ts = NOW();
  RETURN NEW;
END;
$$;
 
 /* The reason for creating a separate functions for the triggers is that it allows for code reusability. 
  * By creating a function, it can be called by multiple triggers, and if the logic of the function needs to be changed, 
  * it only needs to be updated in one place, instead of updating each trigger individually. */

-- _______________TABLES DEFINITION_______________

-- Name: applicants; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.applicants (
    applicant_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    surname nonempty_string NOT NULL,
    given_name VARCHAR(50),
    middle_name VARCHAR(50),
    -- add generated column for applicant's full name
    fullname VARCHAR(151) GENERATED ALWAYS AS (given_name || ' ' || surname) STORED,
    mononym_flag BOOLEAN DEFAULT FALSE NOT NULL,
    email email_pattern NOT NULL UNIQUE,
    birth_date DATE,
	-- since my recruitment agency is international, I do not specify any phone format\pattern    
    phone nonempty_string NOT NULL,
    exp_flag BOOLEAN DEFAULT FALSE NOT NULL,
    edu_flag BOOLEAN DEFAULT FALSE NOT NULL,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Name: categories; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.categories (
    cat_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    category_name nonempty_string NOT NULL UNIQUE,
    description TEXT,
    -- fulltext fields were created for description fields in some tables for full-text search (triggers set in separate part)
    fulltext tsvector,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Name: posiions; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.positions (
    position_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    position_name nonempty_string NOT NULL UNIQUE,
    description TEXT,
    fulltext tsvector,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Name: companies; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.companies (
    company_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    company_name nonempty_string NOT NULL UNIQUE,
    email email_pattern NOT NULL,
    phone VARCHAR(15) NOT NULL,
    description TEXT,
    fulltext tsvector,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Name: hr_managers; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.hr_managers (
    manager_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    surname nonempty_string NOT NULL,
    given_name VARCHAR(50),
    middle_name VARCHAR(50),
    fullname VARCHAR(151) GENERATED ALWAYS AS (given_name || ' ' || surname) STORED,
    phone nonempty_string NOT NULL,
    email email_pattern NOT NULL UNIQUE,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Name: processes; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.processes (
    process_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    -- all FK in this database have update mechanism but the PK they references for cannot be deleted
    manager_id INTEGER NOT NULL REFERENCES recruitment.hr_managers (manager_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    description TEXT,
    fulltext tsvector,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Name: vacancies; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.vacancies (
    vacancy_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    cat_id INTEGER NOT NULL REFERENCES recruitment.categories (cat_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    company_id INTEGER NOT NULL REFERENCES recruitment.companies (company_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    position_id INTEGER REFERENCES recruitment.positions (position_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    process_id INTEGER REFERENCES recruitment.processes (process_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    contract contract_type DEFAULT 'PERMANENT':: contract_type NOT NULL,
    we TEXT,
    edu TEXT,
    created_at DATE DEFAULT CURRENT_DATE,
    closed_at DATE,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    CONSTRAINT created_not_future CHECK (created_at <= CURRENT_DATE),
    -- this constraint checks for correct dates order
    CONSTRAINT clo_pub CHECK (closed_at >= created_at)
    -- I didn't created here unique constraints because a company may place many positions with the same category and process at the same time (e.g. hire 10 developers)
);

-- ___________VACANCIES PARTITIONS___________

/* I created vacancies partitions because one company may provide a large number of vacancies and not only once but many times. 
 * All data for 2023 will be divided into 2 parts.
 * Partitions were created with table inheritance approach. */

CREATE TABLE IF NOT EXISTS recruitment.vacancies_2023_1
    (CHECK (created_at >= DATE '2023-01-01' AND created_at <= DATE '2023-06-30'))
    INHERITS (recruitment.vacancies);
CREATE TABLE IF NOT EXISTS recruitment.vacancies_2023_2
    (CHECK (created_at >= DATE '2023-07-01' AND created_at <= DATE '2023-12-31'))
    INHERITS (recruitment.vacancies);
   
-- foreign keys
ALTER TABLE recruitment.vacancies_2023_1
ADD CONSTRAINT vacancies_2023_1_cat_fk FOREIGN KEY (cat_id) REFERENCES recruitment.categories(cat_id) ON UPDATE CASCADE ON DELETE RESTRICT,
ADD CONSTRAINT vacancies_2023_1_company_fk FOREIGN KEY (company_id) REFERENCES recruitment.companies(company_id) ON UPDATE CASCADE ON DELETE RESTRICT,
ADD CONSTRAINT vacancies_2023_1_position_fk FOREIGN KEY (position_id) REFERENCES recruitment.positions(position_id) ON UPDATE CASCADE ON DELETE RESTRICT,
ADD CONSTRAINT vacancies_2023_1_process_fk FOREIGN KEY (process_id) REFERENCES recruitment.processes(process_id) ON UPDATE CASCADE ON DELETE RESTRICT;

ALTER TABLE recruitment.vacancies_2023_2
ADD CONSTRAINT vacancies_2023_2_cat_fk FOREIGN KEY (cat_id) REFERENCES recruitment.categories(cat_id) ON UPDATE CASCADE ON DELETE RESTRICT,
ADD CONSTRAINT vacancies_2023_2_company_fk FOREIGN KEY (company_id) REFERENCES recruitment.companies(company_id) ON UPDATE CASCADE ON DELETE RESTRICT,
ADD CONSTRAINT vacancies_2023_2_position_fk FOREIGN KEY (position_id) REFERENCES recruitment.positions(position_id) ON UPDATE CASCADE ON DELETE RESTRICT,
ADD CONSTRAINT vacancies_2023_2_process_fk FOREIGN KEY (process_id) REFERENCES recruitment.processes(process_id) ON UPDATE CASCADE ON DELETE RESTRICT;

-- indexes 
CREATE INDEX vacancies_2023_1_created_at ON recruitment.vacancies_2023_1 USING btree (created_at);
CREATE INDEX vacancies_2023_2_created_at ON recruitment.vacancies_2023_2 USING btree (created_at);


-- next, let's create a trigger function to dispatch the data among child tables.
CREATE OR REPLACE FUNCTION on_vacancies_insert() RETURNS TRIGGER 
    LANGUAGE plpgsql
	AS $$
BEGIN
    IF ( NEW.created_at >= DATE '2023-01-01' AND NEW.created_at <= DATE '2023-06-30') THEN
        INSERT INTO vacancies_2023_1 VALUES (NEW.*);
    ELSIF ( NEW.created_at >= DATE '2023-07-01' AND NEW.created_at <= DATE '2023-12-31') THEN
        INSERT INTO vacancies_2023_2 VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION 
       	  'Created_at date out of range';
    END IF;
    RETURN NEW;
END;
$$;

-- let's attach the trigger function defined above to vacancies table
CREATE TRIGGER vacancies_insert BEFORE INSERT ON recruitment.vacancies FOR EACH ROW EXECUTE PROCEDURE on_vacancies_insert();
   
-- Name: applications; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.applications (
    application_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    applicant_id INTEGER NOT NULL REFERENCES recruitment.applicants(applicant_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    vacancy_id INTEGER NOT NULL REFERENCES recruitment.vacancies(vacancy_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    created_at DATE NOT NULL CONSTRAINT appl_not_future CHECK (created_at <= CURRENT_DATE) DEFAULT CURRENT_DATE,
    is_hired BOOLEAN DEFAULT FALSE NOT NULL,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    -- an exclude constraint to ensure that an applicant cannot apply for the same vacancy more than once
    -- the same thing we can do with UNIQUE (for education purposes I used different approach)
	CONSTRAINT unq_app_vacancy EXCLUDE USING GIST (applicant_id WITH =, vacancy_id WITH =)
);

-- partitions; as with vacancies, an applicant can apply on many vacancies, so the data should be divided;
CREATE TABLE IF NOT EXISTS recruitment.applications_2023_1
    (CHECK (created_at >= DATE '2023-01-01' AND created_at <= DATE '2023-06-30'))
    INHERITS (recruitment.applications);
CREATE TABLE IF NOT EXISTS recruitment.applications_2023_2
    (CHECK (created_at >= DATE '2023-07-01' AND created_at <= DATE '2023-12-31'))
    INHERITS (recruitment.applications);

-- foreign keys
ALTER TABLE recruitment.applications_2023_1
ADD CONSTRAINT applications_2023_1_applicant_fk FOREIGN KEY (applicant_id) REFERENCES recruitment.applicants(applicant_id) ON UPDATE CASCADE ON DELETE RESTRICT,
ADD CONSTRAINT applications_2023_1_vacancy_fk FOREIGN KEY (vacancy_id) REFERENCES recruitment.vacancies(vacancy_id) ON UPDATE CASCADE ON DELETE RESTRICT;

ALTER TABLE recruitment.applications_2023_2
ADD CONSTRAINT applications_2023_2_applicant_fk FOREIGN KEY (applicant_id) REFERENCES recruitment.applicants(applicant_id) ON UPDATE CASCADE ON DELETE RESTRICT,
ADD CONSTRAINT applications_2023_2_vacancy_fk FOREIGN KEY (vacancy_id) REFERENCES recruitment.vacancies(vacancy_id) ON UPDATE CASCADE ON DELETE RESTRICT;

-- indexes
CREATE INDEX idx_created_at_1 ON recruitment.applications_2023_1 USING btree (created_at);
CREATE INDEX idx_created_at_2 ON recruitment.applications_2023_2 USING btree (created_at);


-- trigger function to dispatch the data among child tables
CREATE OR REPLACE FUNCTION on_applications_insert() RETURNS TRIGGER 
    LANGUAGE plpgsql
	AS $$
BEGIN
    IF ( NEW.created_at >= DATE '2023-01-01' AND NEW.created_at <= DATE '2023-06-30') THEN
        INSERT INTO applications_2023_1 VALUES (NEW.*);
    ELSIF ( NEW.created_at >= DATE '2023-07-01' AND NEW.created_at <= DATE '2023-12-31') THEN
        INSERT INTO applications_2023_2 VALUES (NEW.*);
    ELSE
        RAISE EXCEPTION 
       	  'Created_at date out of range';
    END IF;
    RETURN NEW;
END;
$$;

-- let's attach the trigger function defined above to vacancies table
CREATE TRIGGER applications_insert BEFORE INSERT ON recruitment.applications FOR EACH ROW EXECUTE PROCEDURE on_applications_insert();
   
-- Name: attachments; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.attachments (
    attachment_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    applicant_id INTEGER NOT NULL REFERENCES recruitment.applicants(applicant_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    attachment_type nonempty_string NOT NULL,
    attachment BYTEA,
    link VARCHAR(2083) UNIQUE,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Name: application_attachment; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.application_attachment (
	id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
	attachment_id INTEGER NOT NULL REFERENCES recruitment.attachments(attachment_id) ON UPDATE CASCADE ON DELETE RESTRICT,
	application_id INTEGER NOT NULL REFERENCES recruitment.applications(application_id) ON UPDATE CASCADE ON DELETE RESTRICT,
	update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Name: experience_details; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.experience_details (
    exp_det_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    applicant_id INTEGER NOT NULL REFERENCES recruitment.applicants (applicant_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    is_current_job BOOLEAN DEFAULT FALSE,
    -- I didn't create an overlap check because an applicant can have two jobs at the same period of time
    start_date DATE,
    end_date DATE,
    job_title VARCHAR(100),
    company_name VARCHAR(100),
    description TEXT,
    fulltext tsvector,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    -- check correct date order
    CONSTRAINT date_order CHECK (end_date >= start_date),
    CONSTRAINT correct_date_exp CHECK (start_date > '1930-01-01' AND start_date < CURRENT_DATE AND end_date > '1930-01-01' AND end_date < CURRENT_DATE)
);

-- Name: education_details; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.education_details (
    edu_det_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    applicant_id INTEGER NOT NULL REFERENCES recruitment.applicants (applicant_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    certificate_name VARCHAR(100),
    major VARCHAR(50),
    university VARCHAR(100),
    start_date DATE,
    end_date DATE,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    -- date checks
    CONSTRAINT date_order CHECK (end_date >= start_date),
    CONSTRAINT correct_date CHECK (start_date > '1930-01-01' AND start_date < CURRENT_DATE AND end_date > '1930-01-01' AND end_date < CURRENT_DATE)
);

-- Name: skills; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.skills (
    skill_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    skill_name nonempty_string NOT NULL UNIQUE,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Name: applicant_skill; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.applicant_skill (
    applicant_id INTEGER NOT NULL REFERENCES recruitment.applicants (applicant_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    skill_id INTEGER NOT NULL REFERENCES recruitment.skills (skill_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    skill_lvl lvl_type NOT NULL DEFAULT 'BEGINNER':: lvl_type,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (applicant_id, skill_id)
);

-- Name: locations; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.locations (
    location_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    country CHAR(2) NOT NULL,
    postal_code VARCHAR(16),
    adm_area VARCHAR(100),
    locality VARCHAR(100),
    thoroughfare VARCHAR(100),
    premise VARCHAR(100),
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Name: entity_location; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.entity_location (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    location_id INTEGER NOT NULL REFERENCES recruitment.locations (location_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    company_id INTEGER REFERENCES recruitment.companies (company_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    applicant_id INTEGER REFERENCES recruitment.applicants (applicant_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    vacancy_id INTEGER REFERENCES recruitment.vacancies (vacancy_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    -- a check constraint that checks that the sum of the filled fields is equal to 1
	-- if any of the fields is NULL, it will be casted to int and become 0, so the sum will only be 1 if only one of the fields is filled
	CONSTRAINT only_one_field_filled CHECK ( (applicant_id IS NOT NULL)::INT + (vacancy_id IS NOT NULL)::INT + (company_id IS NOT NULL)::INT = 1)
);

-- Name: stage; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.stage (
    stage_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    stage_name nonempty_string NOT NULL UNIQUE,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Name: process_stage; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.process_stage (
    process_id INTEGER NOT NULL REFERENCES recruitment.processes (process_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    stage_id INTEGER NOT NULL REFERENCES recruitment.stage (stage_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (process_id, stage_id)
);

-- Name: interviews; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.interviews (
    interview_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    application_id INTEGER NOT NULL REFERENCES recruitment.applications (application_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Name: interview_manager; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.interview_manager (
    id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    interview_id INTEGER NOT NULL REFERENCES recruitment.interviews (interview_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    manager_id INTEGER NOT NULL REFERENCES recruitment.hr_managers (manager_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    result BOOLEAN DEFAULT FALSE NOT NULL,
    feedback TEXT,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Name: application_status; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.application_status (
    status_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    status_type nonempty_string NOT NULL UNIQUE,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Name: application_status; Type: TABLE; Schema: recruitment; Owner: postgres
CREATE TABLE IF NOT EXISTS recruitment.status_change (
    status_id INTEGER NOT NULL REFERENCES recruitment.application_status (status_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    application_id INTEGER NOT NULL REFERENCES recruitment.applications (application_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (status_id, application_id)
);

-- ______________TRIGGERS______________

-- create trigger on birth date
CREATE TRIGGER check_birth_date BEFORE INSERT OR UPDATE ON recruitment.applicants FOR EACH ROW EXECUTE FUNCTION check_birth_date();

-- trigger on update_date
CREATE TRIGGER check_date BEFORE INSERT OR UPDATE ON recruitment.applicants FOR EACH ROW EXECUTE FUNCTION check_date();
 
CREATE TRIGGER check_date BEFORE INSERT OR UPDATE ON recruitment.applications FOR EACH ROW EXECUTE FUNCTION check_date();
  
CREATE TRIGGER check_date BEFORE INSERT OR UPDATE ON recruitment.companies FOR EACH ROW EXECUTE FUNCTION check_date();
  
CREATE TRIGGER check_date BEFORE INSERT OR UPDATE ON recruitment.status_change FOR EACH ROW EXECUTE FUNCTION check_date();
  
CREATE TRIGGER check_date BEFORE INSERT OR UPDATE ON recruitment.vacancies FOR EACH ROW EXECUTE FUNCTION check_date();
  
CREATE TRIGGER check_date BEFORE INSERT OR UPDATE ON recruitment.process_stage FOR EACH ROW EXECUTE FUNCTION check_date();
  
CREATE TRIGGER check_date BEFORE INSERT OR UPDATE ON recruitment.hr_managers FOR EACH ROW EXECUTE FUNCTION check_date();

CREATE TRIGGER check_date BEFORE INSERT OR UPDATE ON recruitment.vacancies_2023_1 FOR EACH ROW EXECUTE FUNCTION check_date();

CREATE TRIGGER check_date BEFORE INSERT OR UPDATE ON recruitment.vacancies_2023_2 FOR EACH ROW EXECUTE FUNCTION check_date();

CREATE TRIGGER check_date BEFORE INSERT OR UPDATE ON recruitment.applications_2023_1 FOR EACH ROW EXECUTE FUNCTION check_date();

CREATE TRIGGER check_date BEFORE INSERT OR UPDATE ON recruitment.applications_2023_2 FOR EACH ROW EXECUTE FUNCTION check_date();

-- upd triggers (update field after table insertion)
CREATE TRIGGER upd_date BEFORE UPDATE ON recruitment.applicants FOR EACH ROW EXECUTE FUNCTION update_date_trigger();
 
CREATE TRIGGER upd_date BEFORE UPDATE ON recruitment.applications FOR EACH ROW EXECUTE FUNCTION update_date_trigger();
  
CREATE TRIGGER upd_date BEFORE UPDATE ON recruitment.companies FOR EACH ROW EXECUTE FUNCTION update_date_trigger();
  
CREATE TRIGGER upd_date BEFORE UPDATE ON recruitment.status_change FOR EACH ROW EXECUTE FUNCTION update_date_trigger();
  
CREATE TRIGGER upd_date BEFORE UPDATE ON recruitment.vacancies FOR EACH ROW EXECUTE FUNCTION update_date_trigger();
  
CREATE TRIGGER upd_date BEFORE UPDATE ON recruitment.process_stage FOR EACH ROW EXECUTE FUNCTION update_date_trigger();
  
CREATE TRIGGER upd_date BEFORE UPDATE ON recruitment.hr_managers FOR EACH ROW EXECUTE FUNCTION update_date_trigger();

CREATE TRIGGER upd_date BEFORE INSERT OR UPDATE ON recruitment.vacancies_2023_1 FOR EACH ROW EXECUTE FUNCTION update_date_trigger();

CREATE TRIGGER upd_date BEFORE INSERT OR UPDATE ON recruitment.vacancies_2023_2 FOR EACH ROW EXECUTE FUNCTION update_date_trigger();

CREATE TRIGGER upd_date BEFORE INSERT OR UPDATE ON recruitment.applications_2023_1 FOR EACH ROW EXECUTE FUNCTION update_date_trigger();

CREATE TRIGGER upd_date BEFORE INSERT OR UPDATE ON recruitment.applications_2023_2 FOR EACH ROW EXECUTE FUNCTION update_date_trigger();

-- fulltext search triggers
CREATE TRIGGER film_fulltext_trigger BEFORE INSERT OR UPDATE ON recruitment.experience_details FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger('fulltext', 'pg_catalog.english', 'description');

CREATE TRIGGER film_fulltext_trigger BEFORE INSERT OR UPDATE ON recruitment.companies FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger('fulltext', 'pg_catalog.english', 'description');

CREATE TRIGGER film_fulltext_trigger BEFORE INSERT OR UPDATE ON recruitment.categories FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger('fulltext', 'pg_catalog.english', 'description');

CREATE TRIGGER film_fulltext_trigger BEFORE INSERT OR UPDATE ON recruitment.positions FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger('fulltext', 'pg_catalog.english', 'description');

CREATE TRIGGER film_fulltext_trigger BEFORE INSERT OR UPDATE ON recruitment.processes FOR EACH ROW EXECUTE PROCEDURE tsvector_update_trigger('fulltext', 'pg_catalog.english', 'description');

-- unique indexes
CREATE UNIQUE INDEX idx_unq_categories_category ON recruitment.categories (category_name);

CREATE UNIQUE INDEX idx_unq_positions_position ON recruitment.positions (position_name);

-- indexes on search fields
CREATE INDEX idx_applicants_name ON recruitment.applicants (surname);

CREATE INDEX idx_companies_name ON recruitment.companies (company_name);

-- __________________________________________INSERTION PART__________________________________________

INSERT INTO recruitment.skills (skill_name) VALUES
	('JAVA'), ('PYTHON'), ('C++'), ('JAVASCRIPT'), ('SQL'), ('PHP'), ('C#'), ('RUBY'), ('SWIFT'), ('KOTLIN'),
	('NODE.JS'), ('REACT'), ('ANGULAR'), ('VUE.JS'), ('DJANGO'), ('FLASK'), ('LARAVEL'), ('SPRING'), ('EXPRESS'), 
	('RAILS'), ('LEADERSHIP'), ('TEAMWORK'), ('COMMUNICATION'), ('PROBLEM SOLVING'), ('TIME MANAGEMENT'), 
	('ADAPTABILITY'), ('STRESS MANAGEMENT'), ('CREATIVITY'), ('NEGOTIATION'), ('CONFLICT RESOLUTION')
-- in this table we have unique constraint on skill_name, duplicated value won't be inserted  
ON CONFLICT ON CONSTRAINT skills_skill_name_key DO NOTHING;

INSERT INTO recruitment.categories (category_name, description) VALUES 
	('IT', 'IMPLEMENTATION, SUPPORT, MAINTENANCE, REPAIR OR PROTECTION OF DATA OR COMPUTER SYSTEMS.'), 
	('FINANCE', 'FINANCIAL MANAGEMENT, ANALYSIS, AND PLANNING.'),
	('EDUCATION', 'TEACHING, TRAINING, OR EDUCATIONAL ADMINISTRATION.')
-- the same uniqueness check	
ON CONFLICT ON CONSTRAINT categories_category_name_key DO NOTHING;

INSERT INTO recruitment.stage (stage_name) VALUES 
	('PREPARING'), 
	('SOURCING'), 
	('SCREENING'), 
	('SELECTING'), 
	('HIRING'), 
	('ONBOARDING')
ON CONFLICT ON CONSTRAINT stage_stage_name_key DO NOTHING;

WITH inserted_data (country, postal_code, adm_area, locality, thoroughfare, premise) AS 
(
VALUES
	('ES', '28001', 'MADRID', 'MADRID', 'GRAN VIA STREET', 'BUILDING 6'),
	('JP', '150-0041', 'TOKYO', 'TOKYO', 'SHIBUYA STREET', 'BUILDING 8'),
	('AR', 'C1012AAB', 'CIUDAD AUTONOMA DE BUENOS AIRES', 'BUENOS AIRES', 'AVENIDA 9 DE JULIO', 'APARTMENT 2'),
	('US', '10011', 'NEW YORK', 'NEW YORK CITY', 'WEST 34TH STREET', '11TH APARATMENT')
)
INSERT INTO recruitment.locations (country, postal_code, adm_area, locality, thoroughfare, premise)
SELECT *
FROM inserted_data
-- data validation insted of check on unique constraint (was deleted)
WHERE NOT EXISTS (SELECT 1 FROM recruitment.locations WHERE country = inserted_data.country AND 
															postal_code = inserted_data.postal_code AND 
															adm_area = inserted_data.adm_area AND 
															locality = inserted_data.locality AND 
															thoroughfare = inserted_data.thoroughfare AND 
															premise = inserted_data.premise);

INSERT INTO recruitment.positions (position_name, description) VALUES 
	('SOFTWARE DEVELOPER', 'DESIGNS, DEVELOPS, TEST, AND MAINTAINS SOFTWARE APPLICATIONS'),
	('QUALITY ASSURANCE ANALYST', 'MONITORS PRODUCT QUALITY, IDENTIFIES AND INVESTIGATES DEFECTS, AND IMPLEMENTS IMPROVEMENTS')
ON CONFLICT ON CONSTRAINT positions_position_name_key DO NOTHING;

WITH inserted_data (surname, given_name, middle_name, phone, email) AS 
(
VALUES
	('DOE', 'JANE', NULL, '81-70-4030-9300', 'JANEDOE@GMAIL.COM'),
	('SMITH', 'JACK', 'ROBERT', '1-505-416-8279', 'JACKRSMITH@GMAIL.COM')
)
INSERT INTO recruitment.hr_managers (surname, given_name, middle_name, phone, email)
SELECT * 
FROM inserted_data
WHERE NOT EXISTS (SELECT 1 FROM recruitment.hr_managers WHERE surname = inserted_data.surname AND
															  given_name = inserted_data.given_name);

INSERT INTO recruitment.application_status (status_type) VALUES
	('RECEIVED'),
	('INCOMPLETE APPLICATION'),
	('IN PROGRESS'),
	('INTERVIEWING'),
	('POSITION CLOSED'),
	('FOR FUTURE CONSIDERATION'),
	('SHORTLISTED'),
	('PROGRESS COMPLETED')
ON CONFLICT ON CONSTRAINT application_status_status_type_key DO NOTHING;

WITH inserted_data (surname, given_name, middle_name, email, birth_date, phone, exp_flag, edu_flag) AS
(
VALUES
	('ONEIL','SCARLET', NULL,'PHARETRA.NAM.AC@OUTLOOK.NET','1968-04-26' :: DATE,'(456) 435-9135','TRUE' :: BOOLEAN,'TRUE':: BOOLEAN),
	('CHRISTENSEN','GERALDINE','CARSON','LACUS.ALIQUAM.RUTRUM@AOL.NET','1999-05-03' :: DATE,'1-209-370-3766','TRUE':: BOOLEAN,'TRUE':: BOOLEAN)
)
INSERT INTO recruitment.applicants (surname, given_name, middle_name, email, birth_date, phone, exp_flag, edu_flag) 
SELECT * FROM inserted_data
WHERE NOT EXISTS (SELECT 1 FROM recruitment.applicants WHERE surname = inserted_data.surname AND
															 given_name = inserted_data.given_name AND
															 phone = inserted_data.phone);

INSERT INTO recruitment.attachments (applicant_id, attachment_type, link)
	   SELECT (SELECT applicant_id FROM applicants WHERE fullname = 'SCARLET ONEIL'), 
	   		  'COVER_LETTER', 'HTTP://WWW.SAMPLE1.ORG/COVER_LETTER'
	   UNION
	   SELECT (SELECT applicant_id FROM applicants WHERE fullname = 'GERALDINE CHRISTENSEN'), 
	   		  'RESUME', 'HTTP://WWW.SAMPLE2.ORG/RESUME'
-- if unique link constraint is violated - the row will be updated	   
ON CONFLICT ON CONSTRAINT attachments_link_key DO UPDATE 
SET applicant_id=EXCLUDED.applicant_id, attachment_type=EXCLUDED.attachment_type, 
	attachment=EXCLUDED.attachment, link=EXCLUDED.link;

WITH inserted_data (applicant_id, certificate_name, major, university, start_date, end_date) AS (
SELECT (SELECT applicant_id FROM applicants WHERE fullname = 'SCARLET ONEIL'),
	   'BACHELOR OF COMPUTER SCIENCE', 
	   'BACHELOR DEGREE', 
	   'UNIVERSITY OF OXFORD', 
	   '2018-09-01' :: DATE, 
	   '2022-06-30' :: DATE
UNION
SELECT (SELECT applicant_id FROM applicants WHERE fullname = 'GERALDINE CHRISTENSEN'),
	   'CERTIFICATE COURSE IN JAVA DEVELOPMENT', 
	   NULL, 
	   NULL, 
	   '2011-09-01' :: DATE, 
	   '2012-06-30' :: DATE
)
INSERT INTO recruitment.education_details (applicant_id, certificate_name, major, university, start_date, end_date)
	   SELECT *
	   FROM inserted_data
	   WHERE NOT EXISTS (SELECT 1 FROM recruitment.education_details WHERE applicant_id = inserted_data.applicant_id AND 
	   																	   certificate_name = inserted_data.certificate_name AND 
	   																	   start_date = inserted_data.start_date);
	   																	  
	   																	  
WITH inserted_data (applicant_id, is_current_job, start_date, job_title, company_name, description) AS (
SELECT (SELECT applicant_id FROM applicants WHERE fullname = 'SCARLET ONEIL'),
	   TRUE, 
	   '2016-11-01' :: DATE, 
	   'DATA ANALYST', 
	   'FACEBOOK', 
	   'COLLECT, ANALYZE AND INTERPRET LARGE SETS OF DATA TO IDENTIFY TRENDS AND INSIGHTS'
UNION
SELECT (SELECT applicant_id FROM applicants WHERE fullname = 'GERALDINE CHRISTENSEN'),
	   TRUE, 
	   '2020-01-12' :: DATE, 
	   'JAVA DEVELOPER', 
	   'ABC COMPANY', 
	   'DEVELOPED AND MAINTAINED JAVA APPLICATIONS'
)
INSERT INTO recruitment.experience_details (applicant_id, is_current_job, start_date, job_title, company_name, description)
	   SELECT *
	   FROM inserted_data
	   WHERE NOT EXISTS (SELECT 1 FROM recruitment.experience_details WHERE applicant_id = inserted_data.applicant_id AND 
	   																	    job_title = inserted_data.job_title AND 
	   																	    company_name = inserted_data.company_name);	   																	  
							
INSERT INTO recruitment.companies (company_name, email, phone, description) VALUES
	('GOOGLE', 'GOOGLE@GMAIL.COM', '+34123456789', 'A MULTINATIONAL TECHNOLOGY COMPANY'),
	('PANASONIC', 'PANASONIC@GMAIL.COM', '+81123456789', 'A MULTINATIONAL CONGLOMERATE CORPORATION')
ON CONFLICT ON CONSTRAINT companies_company_name_key DO NOTHING;
	
INSERT INTO recruitment.processes (manager_id, description)
SELECT (SELECT manager_id FROM hr_managers WHERE fullname = 'JANE DOE'),
'APPLICATION FROM GOOGLE TO HIRE JAVA DEVELOPER FOR THEIR MADRID, SPAIN OFFICE. REQUIREMENTS: EXPERIENCE IN JAVA AND SQL, KNOWLEDGE OF BANKING INDUSTRY.'
UNION
SELECT (SELECT manager_id FROM hr_managers WHERE fullname = 'JACK SMITH'),
'APPLICATION FROM PANASONIC TO HIRE QUALITY ASSURANCE ANALYST FOR THEIR TOKYO, JAPAN OFFICE. REQUIREMENTS: EXPERIENCE IN ELECTRONIC DESIGN AND MANUFACTURING, FLUENT IN JAPANESE.';
	
-- Get the id's of the inserted stages
WITH stage_ids AS (
    SELECT stage_id 
    FROM recruitment.stage 
    WHERE stage_name IN ('PREPARING', 'SOURCING', 'SCREENING', 'SELECTING')
),
-- Get the id's of the inserted processes
	 process_ids AS (
    SELECT process_id 
    FROM recruitment.processes
    WHERE description LIKE '%GOOGLE TO HIRE JAVA DEVELOPER FOR THEIR MADRID, SPAIN OFFICE%' OR 
    	  description LIKE '%PANASONIC TO HIRE QUALITY ASSURANCE ANALYST FOR THEIR TOKYO, JAPAN OFFICE%'
)
-- Insert the process_stage records using the selected id's
INSERT INTO recruitment.process_stage (process_id, stage_id) 
-- let's assume that these two processes are on stage selecting (because we need to fill interviews table)
SELECT process_id, stage_id FROM process_ids CROSS JOIN stage_ids
-- if the same stage for a process in question will be inserted - the record will be updated (update_date)
ON CONFLICT ON CONSTRAINT process_stage_pkey DO NOTHING;
		
									
INSERT INTO recruitment.entity_location (company_id, location_id)
	   SELECT (SELECT company_id FROM recruitment.companies WHERE company_name LIKE 'GOOGLE'),
	   		  (SELECT location_id FROM recruitment.locations WHERE locality = 'MADRID' AND 
	   		  										   			   thoroughfare = 'GRAN VIA STREET' AND 
	   		  										   			   premise = 'BUILDING 6')
	   UNION 
	   SELECT (SELECT company_id FROM recruitment.companies WHERE company_name LIKE 'PANASONIC'),
	   		  (SELECT location_id FROM recruitment.locations WHERE locality = 'TOKYO' AND 
	   		 										   			   thoroughfare = 'SHIBUYA STREET' AND 
	   		 										               premise = 'BUILDING 8');

INSERT INTO recruitment.entity_location (applicant_id, location_id)
	   SELECT (SELECT applicant_id FROM recruitment.applicants WHERE fullname = 'SCARLET ONEIL'), 
			  (SELECT location_id FROM recruitment.locations WHERE locality = 'BUENOS AIRES' AND 
			  										   			   thoroughfare = 'AVENIDA 9 DE JULIO' AND 
			  										   			   premise = 'APARTMENT 2')
	   UNION
	   SELECT (SELECT applicant_id FROM recruitment.applicants WHERE fullname = 'GERALDINE CHRISTENSEN'),
	   		  (SELECT location_id FROM recruitment.locations WHERE locality = 'NEW YORK CITY' AND 
	   		 										   			   thoroughfare = 'WEST 34TH STREET' AND 
	   		 										  			   premise = '11TH APARATMENT');	 
	   		 										 
INSERT INTO recruitment.applicant_skill (applicant_id, skill_id, skill_lvl)
	   SELECT (SELECT applicant_id FROM recruitment.applicants WHERE fullname = 'SCARLET ONEIL'),
	   		  (SELECT skill_id FROM recruitment.skills WHERE skill_name = 'JAVA'),
	   		  'EXPERT' :: lvl_type
	   UNION
	   SELECT (SELECT applicant_id FROM recruitment.applicants WHERE fullname = 'GERALDINE CHRISTENSEN'),
	   		  (SELECT skill_id FROM recruitment.skills WHERE skill_name = 'LEADERSHIP'),
	   		  'EXPERT' :: lvl_type
-- in case of conflict on PK - skill lvl will be updated
ON CONFLICT ON CONSTRAINT applicant_skill_pkey DO UPDATE 
											   SET skill_lvl=EXCLUDED.skill_lvl;	   		 										 

/* Here's the set of CTE with insertion in vacancies, applications, and related tables. 
 * I put it in one query because I have no other solution to catch vacancy/application id for insertion in related tables 
 * without hardcode or cardinally changes of my ERD.
 */
WITH vacancies_insertion AS (
	   INSERT INTO recruitment.vacancies (cat_id, company_id, position_id, process_id, we, edu)
	   SELECT 
	   		  (SELECT cat_id FROM recruitment.categories WHERE category_name = 'IT'),
			  (SELECT company_id FROM recruitment.companies WHERE company_name LIKE 'GOOGLE'),
			  (SELECT position_id FROM recruitment.positions WHERE position_name LIKE 'SOFTWARE DEVELOPER'),
			  (SELECT process_id FROM recruitment.processes WHERE description LIKE '%GOOGLE TO HIRE JAVA DEVELOPER FOR THEIR MADRID, SPAIN OFFICE%'),
			  '3+ YEARS OF WORKING EXPERIENCE',
			  'BD (BACHELOR DEGREE), MASTER DEGREE (MD)'
	   UNION
	   SELECT
			  (SELECT cat_id FROM recruitment.categories WHERE category_name = 'IT'),
			  (SELECT company_id FROM recruitment.companies WHERE company_name LIKE 'PANASONIC'),
			  (SELECT position_id FROM recruitment.positions WHERE position_name LIKE 'QUALITY ASSURANCE ANALYST'),
			  (SELECT process_id FROM recruitment.processes WHERE description LIKE '%PANASONIC TO HIRE QUALITY ASSURANCE ANALYST FOR THEIR TOKYO, JAPAN OFFICE%'),
			  NULL,
			  'ASSOCIATE''S DEGREE AND HIGHER'
			  RETURNING vacancy_id, we),
			  
	 location_insertions AS (			  
	   INSERT INTO recruitment.entity_location (vacancy_id, location_id)
	   		  SELECT vacancy_id,  
			  		 (SELECT location_id 
			  		  FROM recruitment.locations 
			  		  WHERE locality = 'MADRID' AND 
			  		  		thoroughfare = 'GRAN VIA STREET' AND 
			  		  		premise = 'BUILDING 6')
			  FROM vacancies_insertion
			  WHERE we IS NOT NULL
	  		  UNION
	   		  SELECT vacancy_id,
			  		 (SELECT location_id 
			  		  FROM recruitment.locations 
			  		  WHERE locality = 'TOKYO' AND 
			  		  		thoroughfare = 'SHIBUYA STREET' AND 
			  		  		premise = 'BUILDING 8')
			  FROM vacancies_insertion
		      WHERE we IS NULL),
		      
	 applications_insertion AS (
		INSERT INTO recruitment.applications (applicant_id, vacancy_id) 
			   SELECT (SELECT applicant_id FROM recruitment.applicants WHERE fullname = 'SCARLET ONEIL'), 
				      vacancy_id
				      FROM vacancies_insertion
				      WHERE we IS NOT NULL
			   UNION 
			   SELECT (SELECT applicant_id FROM recruitment.applicants WHERE fullname = 'GERALDINE CHRISTENSEN'),
				      vacancy_id
				      FROM vacancies_insertion
				      WHERE we IS NULL
		ON CONFLICT ON CONSTRAINT unq_app_vacancy DO NOTHING
	    RETURNING application_id, vacancy_id),
	    
	 app_attachments_insertion AS (
		INSERT INTO recruitment.application_attachment (attachment_id, application_id)
			   SELECT (SELECT attachment_id FROM recruitment.attachments WHERE link = 'HTTP://WWW.SAMPLE1.ORG/COVER_LETTER'),
				      application_id
				      FROM applications_insertion
				      WHERE vacancy_id = (SELECT vacancy_id FROM vacancies_insertion WHERE we IS NOT NULL)
			   UNION 
		 	   SELECT (SELECT attachment_id FROM recruitment.attachments WHERE link = 'HTTP://WWW.SAMPLE2.ORG/RESUME'),
		 			  application_id
			   		  FROM applications_insertion
			   		  WHERE vacancy_id = (SELECT vacancy_id FROM vacancies_insertion WHERE we IS NULL)),
			   		  
	 interview_insertion AS (
		INSERT INTO recruitment.interviews (application_id)
			   SELECT application_id
				      FROM applications_insertion
				      WHERE vacancy_id = (SELECT vacancy_id FROM vacancies_insertion WHERE we IS NOT NULL)
			   UNION 
		 	   SELECT application_id
			   		  FROM applications_insertion
			   		  WHERE vacancy_id = (SELECT vacancy_id FROM vacancies_insertion WHERE we IS NULL)
		RETURNING *),
		
	 int_manager_insertion AS (
		INSERT INTO recruitment.interview_manager (interview_id, manager_id, result, feedback)
			   SELECT (SELECT interview_id
			   		  FROM interview_insertion
			   		  WHERE application_id = (SELECT application_id
			   		  						  FROM applications_insertion
			   		  						  WHERE vacancy_id = (SELECT vacancy_id FROM vacancies_insertion WHERE we IS NOT NULL))),
			   		  (SELECT manager_id FROM recruitment.hr_managers WHERE fullname = 'JANE DOE'),
			   		  TRUE, 
			   		  'EXTREMELY WELL-PREPARED FOR THE INTERVIEW AND HAD A CLEAR UNDERSTANDING OF THE ROLE AND HOW THE SKILLSET WOULD FIT WITHIN THE COMPANY. ALSO HAD GREAT COMMUNICATION SKILLS AND A POSITIVE ATTITUDE.'
			   UNION 
			   SELECT (SELECT interview_id
			   		  FROM interview_insertion
			   		  WHERE application_id = (SELECT application_id
			   		  						  FROM applications_insertion
			   		  						  WHERE vacancy_id = (SELECT vacancy_id FROM vacancies_insertion WHERE we IS NULL))),
			   		  (SELECT manager_id FROM recruitment.hr_managers WHERE fullname = 'JACK SMITH'),
					  FALSE, 
					  'THE CANDIDATE DID NOT SEEM TO HAVE A STRONG UNDERSTANDING OF THE ROLE AND STRUGGLED TO ANSWER MANY OF THE TECHNICAL QUESTIONS ASKED DURING THE INTERVIEW. ALSO SEEMED DISINTERESTED IN THE COMPANY AND THE POSITION.' 
							   ),
		
	 statuses AS (
	 	SELECT status_id
	 	FROM recruitment.application_status
	 	WHERE status_type IN ('RECEIVED', 'IN PROGRESS', 'INTERVIEWING'))
INSERT INTO recruitment.status_change (status_id, application_id)
	   SELECT status_id, 
	   		  application_id 
	   FROM applications_insertion 
	   CROSS JOIN statuses
ON CONFLICT ON CONSTRAINT status_change_pkey DO NOTHING;