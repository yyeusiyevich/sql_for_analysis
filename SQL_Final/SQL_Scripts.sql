-- _______________SET AUTOCOMMIT MODE ON___________________________

-- drop database
DROP DATABASE IF EXISTS household_appliances_db;
-- database creation
CREATE DATABASE household_appliances_db;

-- _______________CONNECT TO THE DATABASE__________________________
-- _______________TRANSACTION MODE MANUAL\AUTOCOMMIT_______________ 

DROP SCHEMA IF EXISTS ha CASCADE;
-- create new schema
CREATE SCHEMA ha;

-- _______________SELECT HA SCHEMA FOR OBJECTS____________

-- set the search path (if there are any other schemas)
SET search_path = ha;

-- _______________TABLES DEFINITION_______________

CREATE TABLE IF NOT EXISTS ha.streets (
    street_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    street_name VARCHAR(50) NOT NULL UNIQUE,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
 );

CREATE TABLE IF NOT EXISTS ha.districts (
    district_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    district_name VARCHAR(50) NOT NULL UNIQUE,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
 );


CREATE TABLE IF NOT EXISTS ha.street_by_district (
    district_id INTEGER NOT NULL REFERENCES ha.districts (district_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    street_id INTEGER NOT NULL REFERENCES ha.streets (street_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    PRIMARY KEY (district_id, street_id)
 );

CREATE TABLE IF NOT EXISTS ha.customers (
    customer_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    surname VARCHAR(50) NOT NULL,
    given_name VARCHAR(50),
    fullname VARCHAR(101) GENERATED ALWAYS AS (given_name || ' ' || surname) STORED,
    email VARCHAR(255) NOT NULL UNIQUE,
    phone VARCHAR(15) NOT NULL,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    CONSTRAINT email_pattern_check CHECK (email ~* '^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}$')
);

CREATE TABLE IF NOT EXISTS ha.buildings (
    building_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    district_id INTEGER NOT NULL REFERENCES ha.districts (district_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    street_id INTEGER NOT NULL REFERENCES ha.streets (street_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    building_number VARCHAR(5),
    building_description VARCHAR(250),
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS ha.addresses (
    address_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    customer_id INTEGER NOT NULL REFERENCES ha.customers (customer_id) ON UPDATE CASCADE ON DELETE RESTRICT,
	building_id INTEGER NOT NULL REFERENCES ha.buildings (building_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    apartment_number VARCHAR(5),
    additional_details VARCHAR(250),
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

CREATE TABLE IF NOT EXISTS ha.products (
    product_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    product_name VARCHAR(100) NOT NULL,
    description TEXT,
    sku VARCHAR(50) UNIQUE,
    quantity INTEGER,
    unit_price NUMERIC(10, 2),
    category VARCHAR(50),
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    CONSTRAINT products_price_check CHECK (unit_price > 0),
    CONSTRAINT products_quantity_check CHECK (quantity >= 0)
);

CREATE TABLE IF NOT EXISTS ha.shippers (
    shipper_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    surname VARCHAR(50) NOT NULL,
    given_name VARCHAR(50),
    fullname VARCHAR(101) GENERATED ALWAYS AS (given_name || ' ' || surname) STORED,
    phone VARCHAR(15) NOT NULL,
    hire_date DATE NOT NULL DEFAULT CURRENT_DATE, 
    rating NUMERIC(10, 2) DEFAULT 0, 
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    CONSTRAINT rating_check CHECK (rating >= 0),
    CONSTRAINT hire_date CHECK (hire_date <= CURRENT_DATE)
);

CREATE TABLE IF NOT EXISTS ha.orders (
    order_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    address_id INTEGER NOT NULL REFERENCES ha.addresses(address_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    shipper_id INTEGER NOT NULL REFERENCES ha.shippers(shipper_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    customer_id INTEGER NOT NULL REFERENCES ha.customers (customer_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    order_date TIMESTAMP NOT NULL DEFAULT NOW(),
    order_status VARCHAR(20) NOT NULL DEFAULT 'PLACED',
    delivery_date DATE,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    CONSTRAINT order_date CHECK (order_date <= NOW()),
    CONSTRAINT order_status CHECK (order_status IN ('PLACED', 'PROCESSED', 'SHIPPED', 'DELIVERED'))
);

CREATE TABLE IF NOT EXISTS ha.order_details (
    order_detail_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id INTEGER NOT NULL REFERENCES ha.orders(order_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    product_id INTEGER NOT NULL REFERENCES ha.products(product_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    quantity INTEGER NOT NULL, 
    unit_price NUMERIC(10, 2) NOT NULL, 
    discount NUMERIC(10, 2) DEFAULT 0,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    CONSTRAINT quantity_check CHECK (quantity > 0),
    CONSTRAINT price_check CHECK (unit_price > 0)
);

CREATE TABLE IF NOT EXISTS ha.payments (
    payment_id INTEGER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    order_id INTEGER NOT NULL REFERENCES ha.orders(order_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    customer_id INTEGER NOT NULL REFERENCES ha.customers (customer_id) ON UPDATE CASCADE ON DELETE RESTRICT,
    payment_date TIMESTAMP NOT NULL DEFAULT NOW(),
    payment_method VARCHAR(20) NOT NULL DEFAULT 'CASH',
    amount NUMERIC(10, 2) NOT NULL,
    update_ts TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    CONSTRAINT amount_check CHECK (amount > 0),
    CONSTRAINT payment_date CHECK (payment_date <= NOW()),
    CONSTRAINT payment_method CHECK (payment_method IN ('CREDIT CARD', 'DEBIT CARD', 'BANK TRANSFER', 'CASH'))
);

-- ______________TRIGGERS______________

-- this function will automatically sets the value of a 'update_ts' column to the current timestamp whenever a row in a specific table is updated
CREATE OR REPLACE FUNCTION update_ts_trigger() RETURNS TRIGGER
    LANGUAGE plpgsql
    AS $$
BEGIN
  NEW.update_ts = NOW();
  RETURN NEW;
END;
$$;

-- create triggers on all tables 
CREATE TRIGGER upd_ts BEFORE INSERT OR UPDATE ON ha.payments FOR EACH ROW EXECUTE FUNCTION update_ts_trigger();
CREATE TRIGGER upd_ts BEFORE INSERT OR UPDATE ON ha.orders FOR EACH ROW EXECUTE FUNCTION update_ts_trigger();
CREATE TRIGGER upd_ts BEFORE INSERT OR UPDATE ON ha.addresses FOR EACH ROW EXECUTE FUNCTION update_ts_trigger();
CREATE TRIGGER upd_ts BEFORE INSERT OR UPDATE ON ha.customers FOR EACH ROW EXECUTE FUNCTION update_ts_trigger();
CREATE TRIGGER upd_ts BEFORE INSERT OR UPDATE ON ha.order_details FOR EACH ROW EXECUTE FUNCTION update_ts_trigger();
CREATE TRIGGER upd_ts BEFORE INSERT OR UPDATE ON ha.products FOR EACH ROW EXECUTE FUNCTION update_ts_trigger();
CREATE TRIGGER upd_ts BEFORE INSERT OR UPDATE ON ha.shippers FOR EACH ROW EXECUTE FUNCTION update_ts_trigger();
CREATE TRIGGER upd_ts BEFORE INSERT OR UPDATE ON ha.street_by_district FOR EACH ROW EXECUTE FUNCTION update_ts_trigger();
CREATE TRIGGER upd_ts BEFORE INSERT OR UPDATE ON ha.streets FOR EACH ROW EXECUTE FUNCTION update_ts_trigger();
CREATE TRIGGER upd_ts BEFORE INSERT OR UPDATE ON ha.districts FOR EACH ROW EXECUTE FUNCTION update_ts_trigger();
CREATE TRIGGER upd_ts BEFORE INSERT OR UPDATE ON ha.buildings FOR EACH ROW EXECUTE FUNCTION update_ts_trigger();

-- indexes on search fields
CREATE INDEX idx_payments_payment_method ON ha.payments (payment_method);
CREATE INDEX idx_products_category ON ha.products (category);
CREATE INDEX idx_orders_order_status ON ha.orders (order_status);


-- __________________________________________INSERTION PART__________________________________________

-- streets insertion
INSERT INTO ha.streets (street_name)
VALUES
('MAIN STREET'),
('PARK AVENUE'),
('OAK STREET'),
('MAPLE AVENUE'),
('ELM STREET'),
('PINE STREET'),
('WILLOW AVENUE'),
('CEDAR STREET'),
('WALNUT STREET'),
('BIRCH AVENUE')
-- data validation
ON CONFLICT ON CONSTRAINT streets_street_name_key DO NOTHING
RETURNING *;

-- districts insertion
INSERT INTO ha.districts (district_name)
VALUES
('DOWNTOWN'),
('MIDTOWN'),
('UPTOWN'),
('EAST SIDE'),
('WEST SIDE')
-- data validation
ON CONFLICT ON CONSTRAINT districts_district_name_key DO NOTHING
RETURNING *;

-- assign each street to district
INSERT INTO ha.street_by_district (district_id, street_id)
SELECT (SELECT district_id FROM ha.districts WHERE district_name = 'DOWNTOWN'),
	   (SELECT street_id FROM ha.streets WHERE street_name = 'MAIN STREET')
UNION
SELECT (SELECT district_id FROM ha.districts WHERE district_name = 'MIDTOWN'),
	   (SELECT street_id FROM ha.streets WHERE street_name = 'PARK AVENUE')
UNION
SELECT (SELECT district_id FROM ha.districts WHERE district_name = 'UPTOWN'),
	   (SELECT street_id FROM ha.streets WHERE street_name = 'OAK STREET')
UNION
SELECT (SELECT district_id FROM ha.districts WHERE district_name = 'EAST SIDE'),
	   (SELECT street_id FROM ha.streets WHERE street_name = 'MAPLE AVENUE')
UNION
SELECT (SELECT district_id FROM ha.districts WHERE district_name = 'WEST SIDE'),
	   (SELECT street_id FROM ha.streets WHERE street_name = 'ELM STREET')
UNION
SELECT (SELECT district_id FROM ha.districts WHERE district_name = 'DOWNTOWN'),
	   (SELECT street_id FROM ha.streets WHERE street_name = 'PINE STREET')
UNION
SELECT (SELECT district_id FROM ha.districts WHERE district_name = 'MIDTOWN'),
	   (SELECT street_id FROM ha.streets WHERE street_name = 'WILLOW AVENUE')
UNION
SELECT (SELECT district_id FROM ha.districts WHERE district_name = 'UPTOWN'),
	   (SELECT street_id FROM ha.streets WHERE street_name = 'CEDAR STREET')
UNION
SELECT (SELECT district_id FROM ha.districts WHERE district_name = 'EAST SIDE'),
	   (SELECT street_id FROM ha.streets WHERE street_name = 'WALNUT STREET')   
UNION
SELECT (SELECT district_id FROM ha.districts WHERE district_name = 'WEST SIDE'),
	   (SELECT street_id FROM ha.streets WHERE street_name = 'BIRCH AVENUE')
-- data validation	   
ON CONFLICT ON CONSTRAINT street_by_district_pkey DO NOTHING
RETURNING *;

-- customers insertion, store inserted data in CTE to validate it only once
WITH customers_to_insert(surname, given_name, email, phone) AS (
  VALUES 
    ('JOHN', 'DOE', 'JOHN.DOE@EXAMPLE.COM', '123-456-7890'),
    ('JANE', 'DOE', 'JANE.DOE@EXAMPLE.COM', '987-654-3210'),
    ('BOB', 'SMITH', 'BOB.SMITH@EXAMPLE.COM', '555-123-4567'),
    ('ALICE', 'SMITH', 'ALICE.SMITH@EXAMPLE.COM', '555-678-9012'),
    ('MIKE', 'JONES', 'MIKE.JONES@EXAMPLE.COM', '999-888-7777')
)
INSERT INTO ha.customers (surname, given_name, email, phone)
SELECT *
FROM customers_to_insert
-- data validation
WHERE NOT EXISTS (
  SELECT 1 FROM ha.customers c
  WHERE UPPER(c.surname) = customers_to_insert.surname AND
     	UPPER(c.given_name) = customers_to_insert.given_name
)
RETURNING *;

-- CTE to select all pairs district - street
WITH district_street_ids AS (
  SELECT sbd.district_id, sbd.street_id
  FROM ha.street_by_district sbd
)
-- buildings insertion
INSERT INTO ha.buildings (district_id, street_id, building_number, building_description)
SELECT 
  ds.district_id,
  ds.street_id,
  b.building_number,
  UPPER(b.building_description)
FROM district_street_ids ds
-- use cartesian product to insert three buildings for each street
CROSS JOIN LATERAL (
  VALUES 
    ('100', 'Building on ' || (SELECT street_name FROM ha.streets WHERE street_id = ds.street_id) || ' in ' || (SELECT district_name FROM ha.districts WHERE district_id = ds.district_id)),
    ('101', 'Another building on ' || (SELECT street_name FROM ha.streets WHERE street_id = ds.street_id) || ' in ' || (SELECT district_name FROM ha.districts WHERE district_id = ds.district_id)),
    ('102', 'Yet another building on ' || (SELECT street_name FROM ha.streets WHERE street_id = ds.street_id) || ' in ' || (SELECT district_name FROM ha.districts WHERE district_id = ds.district_id))
) b (building_number, building_description)
-- data validation (it's not allowed to have the same bulding number within the same street and district)
WHERE NOT EXISTS (
  SELECT 1 FROM ha.buildings b2
  WHERE b2.district_id = ds.district_id
    AND b2.street_id = ds.street_id
    AND b2.building_number = b.building_number
)
RETURNING *;

-- CTE prepares data for insertion: join customer_id, building_id (based on street name and number) and apartment_number
WITH addresses_to_insert AS (
  SELECT c.customer_id, b.building_id, a.apartment_number
  FROM ha.customers c
  INNER JOIN (VALUES 
    ('DOE JOHN', 'MAIN STREET', '100', '1A'),
    ('DOE JANE', 'PARK AVENUE', '100', '2B'),
    ('SMITH BOB', 'OAK STREET', '100', '3C'),
    ('SMITH ALICE', 'MAPLE AVENUE', '100', '4D'),
    ('JONES MIKE', 'ELM STREET', '100', '5E')
  ) a (fullname, street_name, building_number, apartment_number)
    ON c.fullname = a.fullname
  INNER JOIN ha.buildings b ON b.street_id = (SELECT street_id FROM ha.streets WHERE street_name = a.street_name) AND 
  										  											 b.building_number = a.building_number
), 
unique_addresses AS (
  SELECT a.*
  FROM addresses_to_insert a
  -- data validation (customer with the same building_id i.e. within the same street and number is not allowed)
  WHERE NOT EXISTS (
    SELECT 1 
    FROM ha.addresses addr
    WHERE addr.customer_id = a.customer_id AND addr.building_id = a.building_id
  )
)
-- addresses insertion
INSERT INTO ha.addresses (customer_id, building_id, apartment_number, additional_details)
SELECT ua.customer_id, ua.building_id, ua.apartment_number, NULL
FROM unique_addresses ua
RETURNING *;

-- products data
WITH products_to_insert (product_name, description, sku, quantity, unit_price, category) AS (
  VALUES 
    ('WIDGET A', 'A POPULAR WIDGET', 'WIDG-A', 100, 10.99, 'WIDGETS'),
    ('WIDGET B', 'A PREMIUM WIDGET', 'WIDG-B', 50, 24.99, 'WIDGETS'),
    ('GIZMO X', 'A NEW GIZMO', 'GIZ-X', 25, 49.99, 'GIZMOS'),
    ('GIZMO Y', 'AN UPGRADED GIZMO', 'GIZ-Y', 10, 89.99, 'GIZMOS'),
    ('THINGAMAJIG Z', 'A STRANGE THINGAMAJIG', 'THING-Z', 5, 199.99, 'THINGAMAJIGS')
)
-- products insertion
INSERT INTO ha.products (product_name, description, sku, quantity, unit_price, category)
SELECT *
FROM products_to_insert
-- data validation (no prodcuts with the same sku)
ON CONFLICT ON CONSTRAINT products_sku_key DO NOTHING
RETURNING *;

-- shippers data
WITH shippers_to_insert (surname, given_name, phone, rating) AS (
  VALUES 
    ('SMITH', 'JOHN', '111-111-1111', 1.5),
    ('DAVIS', 'JANE', '222-222-2222', 3.2),
    ('BROWN', 'JAMES', '333-333-3333', 4.8),
    ('WILSON', 'SARAH', '444-444-4444', 4.1),
    ('MARTIN', 'MICHAEL', '555-555-5555', 2.3)
)
-- shippers insertion
INSERT INTO ha.shippers (surname, given_name, phone, rating)
SELECT *
FROM shippers_to_insert
-- validation
WHERE NOT EXISTS (
  SELECT 1 FROM ha.shippers s
  WHERE UPPER(s.surname) = shippers_to_insert.surname
  AND UPPER(s.given_name) = shippers_to_insert.given_name
)
RETURNING *;

/* The following function inserts a new order into the orders table. 
 * The function takes in several input parameters, including the customer's name, 
 * the shipper's name, the street name, the building number, the apartment number, 
 * the order date, the order status, and the delivery date.
 * The function queries the customers, shippers, streets, buildings, and addresses tables 
 * to obtain the IDs for the customer, shipper, street, building, and address associated with the order. 
 * It then attempts to insert the new order into the orders table, but only if an order with the same customer 
 * and order date (up to minute) does not already exist in the table.
 * The function returns a set of rows containing the data for the inserted order. */

-- DROP FUNCTION ha.insert_order;
CREATE OR REPLACE FUNCTION ha.insert_order(
  customer VARCHAR(101),
  shipper VARCHAR(101),
  street VARCHAR(50),
  building VARCHAR(5),
  apartment VARCHAR(5),
  order_dt TIMESTAMP DEFAULT NOW(),
  status VARCHAR(20) DEFAULT 'PLACED',
  delivery DATE DEFAULT NULL
) RETURNS SETOF ha.orders AS $$
DECLARE
  c_id INTEGER;
  s_id INTEGER;
  st_id INTEGER;
  b_id INTEGER;
  a_id INTEGER;
BEGIN
  -- Find customer ID based on customer fullname
  SELECT customer_id INTO c_id FROM ha.customers WHERE fullname = customer;
  -- Find shipper ID based on shipper fullname
  SELECT shipper_id INTO s_id FROM ha.shippers WHERE fullname = shipper;
  -- Find street ID based on street name
  SELECT street_id INTO st_id FROM ha.streets WHERE streets.street_name = street;
  -- Find building ID based on street ID and building number
  SELECT building_id INTO b_id FROM ha.buildings WHERE street_id = st_id AND buildings.building_number = building;
  -- Find address ID based on building ID and apartment number
  SELECT address_id INTO a_id FROM ha.addresses WHERE building_id = b_id AND addresses.apartment_number = apartment;
  -- Insert customer, shipper, and address IDs into orders table
  RETURN QUERY
  INSERT INTO ha.orders (address_id, shipper_id, customer_id, order_date, order_status, delivery_date)
  SELECT a_id, s_id, c_id, order_dt, status, delivery
  -- validation
  WHERE NOT EXISTS (
    SELECT 1 FROM ha.orders ord
    WHERE ord.customer_id = c_id AND 
          DATE_TRUNC('minute', ord.order_date) = DATE_TRUNC('minute', NOW())
  )
  RETURNING *;
END;
$$ LANGUAGE plpgsql;

WITH order_insertion AS (
  -- call previous created function to obtain the order_id
  SELECT * FROM ha.insert_order('DOE JOHN', 'JOHN SMITH', 'MAIN STREET', '100', '1A', '2023-01-01 00:00:00.000') 
),
	 -- prepare data for order_detils insertion: order_id from function, product_id based on product name
	 inserted_data (order_id, product_id, quantity, unit_price, discount) AS (
	 -- this customer has ordered two items within one order
  VALUES ((SELECT order_id FROM order_insertion), (SELECT product_id FROM ha.products p WHERE p.sku = 'WIDG-A'), 1, 4.99, 0),
  		 ((SELECT order_id FROM order_insertion), (SELECT product_id FROM ha.products p WHERE p.sku = 'WIDG-B'), 1, 24.99, 0)
) 
-- order_details insertion
INSERT INTO ha.order_details (order_id, product_id, quantity, unit_price, discount)
SELECT * FROM inserted_data
-- data validation plus if order is duplicated (no row was inserted, function returns nothing) the followinf insertion won't be perfomed
WHERE inserted_data.order_id IS NOT NULL AND 
	  NOT EXISTS (SELECT 1 FROM ha.order_details ord_det WHERE ord_det.order_id = inserted_data.order_id AND
															   product_id = inserted_data.product_id)
RETURNING *;

-- place orders for other customers
WITH order_insertion AS (
  SELECT * FROM ha.insert_order('DOE JANE', 'JANE DAVIS', 'PARK AVENUE', '100', '2B', '2023-01-02 00:00:00.000') 
),
	 inserted_data (order_id, product_id, quantity, unit_price, discount) AS (
  	 VALUES ((SELECT order_id FROM order_insertion), (SELECT product_id FROM ha.products p WHERE p.sku = 'WIDG-B'), 1, 24.99, 0)
) 
INSERT INTO ha.order_details (order_id, product_id, quantity, unit_price, discount)
SELECT * FROM inserted_data
WHERE inserted_data.order_id IS NOT NULL AND 
	  NOT EXISTS (SELECT 1 FROM ha.order_details ord_det WHERE ord_det.order_id = inserted_data.order_id AND
															   product_id = inserted_data.product_id)
RETURNING *;

WITH order_insertion AS (
  SELECT * FROM ha.insert_order('SMITH BOB', 'JAMES BROWN', 'OAK STREET', '100', '3C', '2023-01-03 00:00:00.000') 
),
	 inserted_data (order_id, product_id, quantity, unit_price, discount) AS (
  	 VALUES ((SELECT order_id FROM order_insertion), (SELECT product_id FROM ha.products p WHERE p.sku = 'WIDG-B'), 1, 24.99, 0),
  		 	((SELECT order_id FROM order_insertion), (SELECT product_id FROM ha.products p WHERE p.sku = 'GIZ-X'), 1, 49.99, 0)
) 
INSERT INTO ha.order_details (order_id, product_id, quantity, unit_price, discount)
SELECT * FROM inserted_data
WHERE inserted_data.order_id IS NOT NULL AND 
	  NOT EXISTS (SELECT 1 FROM ha.order_details ord_det WHERE ord_det.order_id = inserted_data.order_id AND
															   product_id = inserted_data.product_id)
RETURNING *;

WITH order_insertion AS (
  SELECT * FROM ha.insert_order('SMITH ALICE', 'SARAH WILSON', 'MAPLE AVENUE', '100', '4D', '2023-01-04 00:00:00.000') 
),
	 inserted_data (order_id, product_id, quantity, unit_price, discount) AS (
  	 VALUES ((SELECT order_id FROM order_insertion), (SELECT product_id FROM ha.products p WHERE p.sku = 'GIZ-Y'), 1, 89.99, 0)
) 
INSERT INTO ha.order_details (order_id, product_id, quantity, unit_price, discount)
SELECT * FROM inserted_data
WHERE inserted_data.order_id IS NOT NULL AND 
	  NOT EXISTS (SELECT 1 FROM ha.order_details ord_det WHERE ord_det.order_id = inserted_data.order_id AND
															   product_id = inserted_data.product_id)
RETURNING *;

WITH order_insertion AS (
  SELECT * FROM ha.insert_order('JONES MIKE', 'MICHAEL MARTIN', 'ELM STREET', '100', '5E', '2023-01-05 00:00:00.000') 
),
	 inserted_data (order_id, product_id, quantity, unit_price, discount) AS (
  	 VALUES ((SELECT order_id FROM order_insertion), (SELECT product_id FROM ha.products p WHERE p.sku = 'THING-Z'), 1, 199.99, 0)
) 
INSERT INTO ha.order_details (order_id, product_id, quantity, unit_price, discount)
SELECT * FROM inserted_data
WHERE inserted_data.order_id IS NOT NULL AND 
	  NOT EXISTS (SELECT 1 FROM ha.order_details ord_det WHERE ord_det.order_id = inserted_data.order_id AND
															   product_id = inserted_data.product_id)
RETURNING *;

/* This function adds new transaction to the transaction table (payments),
 * It takes in several parameters: customer, product_skus, amount, payment_date, and method. 
 * First, the function finds the customer_id based on the fullname of the customer passed in. 
 * It then finds the order_id based on the product_sku passed in, by joining the order_details table with the products table.
 * The function returns inserted rows. */

-- DROP FUNCTION ha.insert_payment;
CREATE OR REPLACE FUNCTION ha.insert_payment(
  customer VARCHAR(101),
  product_skus VARCHAR[],
  amount NUMERIC,
  payment_date TIMESTAMP DEFAULT NOW(),
  method VARCHAR(20) DEFAULT 'CASH'
) RETURNS SETOF ha.payments  AS $$
DECLARE
  c_id INTEGER;
  o_id INTEGER;
  p_id INTEGER;
BEGIN
  -- Find customer ID based on customer fullname
  SELECT customer_id INTO c_id FROM ha.customers WHERE fullname = customer;
  -- Find order ID based on product SKU
  SELECT od.order_id INTO o_id FROM ha.order_details od
  INNER JOIN ha.products p ON p.product_id = od.product_id
  WHERE p.sku = ANY(product_skus);
  -- Insert payment record
  RETURN QUERY
  INSERT INTO ha.payments (order_id, customer_id, payment_date, payment_method, amount)
  SELECT o_id, c_id, payment_date, METHOD, amount
  RETURNING *;
END;
$$ LANGUAGE plpgsql;

-- insert payments for customers
SELECT * FROM ha.insert_payment('DOE JOHN', ARRAY['WIDG-A', 'WIDG-b'], 29.98, '2023-01-01 00:00:00.000');
SELECT * FROM ha.insert_payment('DOE JANE', ARRAY['WIDG-B'], 24.99, '2023-01-02 00:00:00.000');
SELECT * FROM ha.insert_payment('SMITH BOB', ARRAY['WIDG-B', 'GIZ-X'], 74.98, '2023-01-03 00:00:00.000');
SELECT * FROM ha.insert_payment('SMITH ALICE', ARRAY['GIZ-Y'], 89.99, '2023-01-04 00:00:00.000');
SELECT * FROM ha.insert_payment('JONES MIKE', ARRAY['THING-Z'], 199.99, '2023-01-05 00:00:00.000');


-- __________________________________________FUNCTIONS PART__________________________________________

/* 1. Function that UPDATEs data in products table (input arguments: table's primary key value, 
 * column name and column value to UPDATE to).
 * The function returns update row based on PK specified. */

-- DROP FUNCTION ha.update_products_table;
CREATE OR REPLACE FUNCTION ha.update_products_table(pk_value INTEGER, col_name TEXT, col_value ANYELEMENT)
RETURNS TABLE (
				product_name VARCHAR(100),
				desription TEXT,
				sku VARCHAR(50),
				quantity INTEGER,
				unit_price NUMERIC
)
AS $$
BEGIN
  EXECUTE 'UPDATE ha.products SET ' || LOWER(col_name) || ' = $1 WHERE product_id = $2'
  USING UPPER(col_value), pk_value;
  RETURN QUERY
  SELECT p.product_name, p.description, p.sku, p.quantity, p.unit_price 
  FROM ha.products p
  WHERE p.product_id = pk_value;
END;
$$ LANGUAGE plpgsql;

-- test
SELECT * FROM ha.update_products_table(1, 'product_name', 'SUPER WIDGET A'::TEXT);

-- 2. Payment function already exixsts;

-- __________________________________________VIEW PART__________________________________________

-- DROP VIEW ha.denormalized_data;
CREATE OR REPLACE VIEW ha.denormalized_data AS 
SELECT 
  c.fullname AS customer_name, 
  c.email,
  c.phone AS customer_phone,
  s.fullname AS shipper_name, 
  s.phone AS shipper_phone,
  s.rating,
  st.street_name, 
  b.building_number, 
  a.apartment_number, 
  o.order_date, 
  o.order_status, 
  o.delivery_date, 
  p.product_name, 
  p.unit_price, 
  od.quantity, 
  od.discount,
  (p.unit_price * od.quantity * (1 - od.discount)) AS total_price,
  pm.payment_date,
  pm.payment_method,
  pm.amount
FROM 
  ha.orders o 
  INNER JOIN ha.customers c ON o.customer_id = c.customer_id 
  INNER JOIN ha.shippers s ON o.shipper_id = s.shipper_id 
  INNER JOIN ha.addresses a ON o.address_id = a.address_id 
  INNER JOIN ha.buildings b ON a.building_id = b.building_id 
  INNER JOIN ha.streets st ON b.street_id = st.street_id 
  INNER JOIN ha.order_details od ON o.order_id = od.order_id 
  INNER JOIN ha.products p ON od.product_id = p.product_id 
  INNER JOIN ha.payments pm ON pm.customer_id = c.customer_id
WHERE 
  -- specify orders interval (previous month)
  (o.order_date BETWEEN DATE_TRUNC('month', NOW()) - INTERVAL '1 month' AND DATE_TRUNC('month', NOW())) AND
  -- specify payments interval (previous month)
  (pm.payment_date BETWEEN DATE_TRUNC('month', NOW()) - INTERVAL '1 month' AND DATE_TRUNC('month', NOW()));
 
 -- test
SELECT * FROM ha.denormalized_data;

-- __________________________________________DCL PART__________________________________________

-- REVOKE ALL ON SCHEMA ha fROM manager;
-- REVOKE ALL ON ALL TABLES IN SCHEMA ha FROM manager;
-- DROP ROLE manager;

-- create manager role and grant privileges
DO $$
BEGIN	
    IF NOT EXISTS (SELECT * FROM pg_roles WHERE rolname = 'manager') THEN
      CREATE ROLE manager LOGIN;
    ELSE
      RAISE NOTICE 'Role manager already exists. Skipping.';
    END IF;
    -- grant read-only privileges to the manager role
	-- access to schema objects
	GRANT USAGE ON SCHEMA ha TO manager;
	-- read-only access to the tables
	GRANT SELECT ON ALL TABLES IN SCHEMA ha TO manager;
END
$$;

-- test
SET ROLE manager;
SELECT * FROM ha.customers;
-- access restrict
-- DELETE FROM ha.customers;
RESET ROLE;

-- can login test
SELECT rolcanlogin FROM pg_roles WHERE rolname = 'manager';


